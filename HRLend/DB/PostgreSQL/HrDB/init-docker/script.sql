create schema hr;create table hr.cabinet
(
    id integer primary key
);create table hr.skill_need
(
    id integer primary key generated by default as identity,
	title text not null unique
);create table hr.competence_need
(
    id integer primary key generated by default as identity,
	title text not null unique
);create table hr.test_template
(
    id integer primary key generated by default as identity,
    cabinet_id integer,
	title text not null,
    
    unique(cabinet_id, title),
    foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.competence
(
    id integer primary key generated by default as identity,
    cabinet_id integer,
	title text not null,

    unique(cabinet_id, title),
    foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.skill
(
    id integer primary key generated by default as identity,
	cabinet_id integer,
	title text not null,
	test_module_link text not null,

	unique(cabinet_id, title),
	foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.test_template_and_competence
(
    test_template_id integer not null,
	competence_id integer not null,
	competence_need_id integer not null,

	foreign key (test_template_id) references hr.test_template (id) on delete cascade,
	foreign key (competence_id) references hr.competence (id) on delete cascade,
	foreign key (competence_need_id) references hr.competence_need (id) on delete cascade,
	primary key(test_template_id, competence_id)
);create table hr.competence_and_skill
(
    skill_id integer not null,
	competence_id integer not null,
	skill_need_id integer not null,

	foreign key (skill_id) references hr.skill (id) on delete cascade,
	foreign key (competence_id) references hr.competence (id) on delete cascade,
	foreign key (skill_need_id) references hr.skill_need (id) on delete cascade,
	primary key(skill_id, competence_id)
);
CREATE OR REPLACE FUNCTION hr.competence_and_skill__get(
		_ref_competence refcursor,
		_ref_skill refcursor,
		_id integer,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_competence  FOR
				SELECT
					c.title AS title
				FROM hr.competence  c
				WHERE c.id = _id AND c.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_competence;
				
			OPEN _ref_skill FOR
				SELECT 
					s.id AS skill_id,
					s.title AS skill_title,
					s_n.title AS skill_need_title,
					s_n.id AS skill_need_id
				FROM  hr.skill AS s
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.skill_id = s.id
				JOIN hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id
				where c_a_s.competence_id = _id AND s.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_skill;
			
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.competence__select(
		_ref_competence refcursor,
		_ref_skill refcursor,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN

			CREATE TEMP TABLE temp_competence ON COMMIT DROP AS
      		SELECT * FROM hr.competence AS c
			WHERE c.cabinet_id = _cabinet_id;
		
			OPEN _ref_competence FOR
				SELECT 
					c.id AS id,
					c.title AS title
				FROM temp_competence AS c;
			RETURN NEXT _ref_competence;
			
			OPEN _ref_skill FOR
				SELECT 
					c.id AS competence_id,
					s.id AS skill_id,
					s.title AS skill_title,
					s_n.id AS skill_need_id,
					s_n.title AS skill_need_title
				FROM  temp_competence AS c
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.competence_id = c.id
				JOIN hr.skill AS s ON c_a_s.skill_id = s.id
				join hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id;
			RETURN NEXT _ref_skill;
			
		END;
    $$
	LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION hr.competence__select(
		_ref_competence refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_competence FOR
				SELECT 
					c.id AS id,
					c.title AS title
				FROM hr.competence AS c
				WHERE c.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN c.title END ASC,
					CASE WHEN _sort = 'desc' THEN c.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_competence;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.competence
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.skill__get(
		_id integer,
		_cabinet_id integer
	) RETURNS TABLE (
		title text,
		test_module_link text
	) AS
	$$
		BEGIN
			RETURN QUERY
				SELECT 
					s.title AS title,
					s.test_module_link AS test_module_link
				FROM hr.skill AS s
				WHERE s.id = _id and s.cabinet_id = _cabinet_id;
		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.skill__select(
		_ref_skill refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			
			OPEN _ref_skill FOR
				SELECT 
					s.id AS id,
					s.title AS title,
					s.test_module_link AS test_module_link
				FROM hr.skill AS s
				WHERE s.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN s.title END ASC,
					CASE WHEN _sort = 'desc' THEN s.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_skill;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.skill
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.test_template_and_competence_and_skill__get(
		_ref_test_template refcursor, 
		_ref_competence refcursor, 
		_ref_skill refcursor,
		_id integer,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN

			OPEN _ref_test_template FOR
				SELECT 
					t_t.title AS title
				FROM hr.test_template  t_t
				WHERE id = _id AND t_t.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_test_template ;
			
			CREATE TEMP TABLE temp_competence ON COMMIT DROP AS
      		SELECT * FROM hr.competence AS c
            	JOIN hr.test_template_and_competence AS t_t_a_c ON c.id = t_t_a_c.competence_id AND c.cabinet_id = _cabinet_id
			WHERE t_t_a_c.test_template_id = _id;
   
   			OPEN _ref_competence FOR
				SELECT 
					c.id AS competence_id,
					c.title AS competence_title,
					c.competence_need_id AS competence_need_id,
					c_n.title AS competence_need_title
				FROM temp_competence AS c
				JOIN hr.competence_need AS c_n ON c_n.id = c.competence_need_id;
   			RETURN NEXT _ref_competence;
				
			OPEN _ref_skill FOR
				SELECT 
					c.id AS competence_id,
					s.id AS skill_id,
					s.title AS skill_title,
					s.test_module_link AS skill_test_module_link,
					s_n.id AS skill_need_id,
					s_n.title AS skill_need_title
				FROM  temp_competence AS c
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.competence_id = c.id
				JOIN hr.skill AS s ON c_a_s.skill_id = s.id
				join hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id;
			RETURN NEXT _ref_skill;
			
		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.test_template__select(
		_ref_test_template refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_test_template FOR
				SELECT 
					t_t.id AS id,
					t_t.title AS title
				FROM hr.test_template AS t_t
				WHERE t_t.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN t_t.title END ASC,
					CASE WHEN _sort = 'desc' THEN t_t.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_test_template;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.test_template
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.cabinet__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.cabinet
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.cabinet__insert(
        _id integer
	) AS
	$$		
		BEGIN
			INSERT INTO hr.cabinet (
					id
				) 
				VALUES (
					_id
				);
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__copy(
		_cabinet_id integer,
		out _id_competence integer,
		_competence_copy_json jsonb
	) AS
	$$
		DECLARE skill_json jsonb;

		BEGIN

			/*
			Если в кабинете имеются аналогичная компетенция, то узнаем его id,
			и не дублируем.
			*/
			SELECT c.id INTO _id_competence
			FROM hr.competence c
			WHERE 
				c.cabinet_id = _cabinet_id AND
				c.title = SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2);

			IF _id_competence IS NULL THEN
				INSERT INTO hr.competence 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO _id_competence;

				FOR skill_json IN 
					SELECT value FROM jsonb_array_elements(_competence_copy_json->'Skills')
				LOOP
					call hr.hellper__copy_skill(
						_cabinet_id,
						_id_competence,
						skill_json
					);
				END LOOP;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__copy_skill(
		_cabinet_id integer,
		_id_competence integer,
		_skill_copy_json jsonb
	) AS
	$$
		DECLARE skill_id integer;

		BEGIN
			/*
			Если в кабинете имеются аналогичный навык, то узнаем его id,
			и не дублируем.
			*/
			SELECT s.id INTO skill_id
			FROM hr.skill s
			WHERE 
				s.cabinet_id = _cabinet_id AND
				s.title = SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2);

			IF skill_id IS NULL THEN
				INSERT INTO hr.skill 
				(
					cabinet_id,
					title, 
					test_module_link
				) VALUES 
				(
					_cabinet_id,
					 SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2),
					 SUBSTRING((_skill_copy_json->'TestModuleLink')::text, 2, LENGTH((_skill_copy_json->'TestModuleLink')::text) - 2)
				)
				RETURNING id INTO skill_id;
			END IF;

			/*
			Соединяем компетенцию с навыком
			*/
			INSERT INTO hr.competence_and_skill
			(
				competence_id,
				skill_id,
				skill_need_id
			) VALUES(
				_id_competence,
				skill_id,
				(_skill_copy_json->>'SkillNeed')::integer
			);
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.competence
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__insert(
		_cabinet_id integer,
        _title text,
		out _id_competence integer,
		_skill_ids integer[] default null,
		_skill_need_ids integer[] default null
	) AS
	$$
		BEGIN
			INSERT INTO hr.competence 
			(
				cabinet_id,
				title
			) 
			VALUES 
			(
				_cabinet_id,
				_title
			)
			RETURNING id INTO _id_competence;
				
			IF NOT (_skill_ids IS NULL) THEN
				INSERT INTO hr.competence_and_skill(
					competence_id,
					skill_id,
					skill_need_id
				)
				SELECT _id_competence, unnest(_skill_ids), unnest(_skill_need_ids);
			END IF;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__update(
		_id integer,
		_title text,
		_skill_ids integer[] default null,
		_skill_need_ids integer[] default null
	) AS
	$$		
		BEGIN
			UPDATE hr.competence SET title = _title
			WHERE id = _id;
				
			IF  NOT (_skill_ids IS NULL) THEN
				DELETE FROM hr.competence_and_skill
				WHERE competence_id = _id;
			
				INSERT INTO hr.competence_and_skill(
					competence_id,
					skill_id,
					skill_need_id
				)
				SELECT _id, unnest(_skill_ids), unnest(_skill_need_ids);
			END IF;
		END;
	$$
	LANGUAGE plpgsql;



CREATE OR REPLACE PROCEDURE hr.competence__update_constructor(
		_competence_json jsonb
	) AS
	$$
		DECLARE skill_json jsonb;

		BEGIN

			IF (_competence_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.competence SET
					title = SUBSTRING((_competence_json->'Title')::text, 2, LENGTH((_competence_json->'Title')::text) - 2)
				WHERE id = (_competence_json->>'Id')::integer;
			END IF;

			DELETE FROM hr.competence_and_skill
			WHERE competence_id = (_competence_json->>'Id')::integer;

			FOR skill_json IN 
				SELECT value FROM jsonb_array_elements(_competence_json->'Skills')
			LOOP

				INSERT INTO hr.competence_and_skill
				(
					competence_id,
					skill_id,
					skill_need_id
				) VALUES(
					(_competence_json->>'Id')::integer,
					(skill_json->>'Id')::integer,
					(skill_json->>'SkillNeed')::integer
				);

				call hr.hellper__update_skill_constructor(
					skill_json
				);
			END LOOP;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__update_skill_constructor(
		_skill_json jsonb
	) AS
	$$

		BEGIN

			IF (_skill_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.skill SET
					title = SUBSTRING((_skill_json->'Title')::text, 2, LENGTH((_skill_json->'Title')::text) - 2)
				WHERE id = (_skill_json->>'Id')::integer;
			END IF;
				
		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.skill__copy(
		_cabinet_id integer,
		out _id_skill integer,
		_skill_copy_json jsonb
	) AS
	$$
		BEGIN

			/*
			Если в кабинете имеются аналогичный навык, то узнаем его id,
			и не дублируем одинаковые навыки.
			*/
			SELECT s.id INTO _id_skill
			FROM hr.skill s
			WHERE 
				s.cabinet_id = _cabinet_id AND
				s.title = SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2);

			IF _id_skill IS NULL THEN
				INSERT INTO hr.skill 
				(
					cabinet_id,
					title, 
					test_module_link
				) VALUES 
				(
					_cabinet_id,
					SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2),
					SUBSTRING((_skill_copy_json->'TestModuleLink')::text, 2, LENGTH((_skill_copy_json->'TestModuleLink')::text) - 2)
				)
				RETURNING id INTO _id_skill;
			END IF;
				
		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.skill__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.skill
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.skill__insert(
		_cabinet_id integer,
        _title text,
		_test_module_link text,
		out _id_skill integer
	) AS
	$$
		BEGIN
			INSERT INTO hr.skill 
			(
				cabinet_id,
				title, 
				test_module_link
			) VALUES 
			(
				_cabinet_id,
				_title,
				_test_module_link
			)
			RETURNING id INTO _id_skill;
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.skill__update(
		_id integer,
		_title text,
		_test_module_link text
	) AS
	$$		
		BEGIN
			UPDATE hr.skill 
			SET 
				title = _title,
				test_module_link = _test_module_link
			WHERE id = _id;
				
		END;
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.test_template__copy(
		_cabinet_id integer,
		out _id_test_template integer,
		_template_copy_json jsonb
	) AS
	$$
		DECLARE competence_json jsonb;

		BEGIN

			/*
			Если в кабинете имеются аналогичный шаблон, то узнаем его id,
			и не дублируем.
			*/
			SELECT t.id INTO _id_test_template
			FROM hr.test_template t
			WHERE 
				t.cabinet_id = _cabinet_id AND
				t.title = SUBSTRING((_template_copy_json->'Title')::text, 2, LENGTH((_template_copy_json->'Title')::text) - 2);

			IF _id_test_template IS NULL THEN
				INSERT INTO hr.test_template 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_template_copy_json->'Title')::text, 2, LENGTH((_template_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO _id_test_template;

				FOR competence_json IN 
					SELECT value FROM jsonb_array_elements(_template_copy_json->'Competencies')
				LOOP
					call hr.hellper__copy_competence(
						_cabinet_id,
						_id_test_template,
						competence_json
					);
				END LOOP;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__copy_competence(
		_cabinet_id integer,
		_id_test_template integer,
		_competence_copy_json jsonb
	) AS
	$$
		DECLARE 
			skill_json jsonb;
			competence_id integer;
		BEGIN

			/*
			Если в кабинете имеются аналогичная компетенция, то узнаем его id,
			и не дублируем.
			*/
			SELECT c.id INTO competence_id
			FROM hr.competence c
			WHERE 
				c.cabinet_id = _cabinet_id AND
				c.title = SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2);

			IF competence_id IS NULL THEN
				INSERT INTO hr.competence 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO competence_id;

				FOR skill_json IN 
					SELECT value FROM jsonb_array_elements(_competence_copy_json->'Skills')
				LOOP
					call hr.hellper__copy_skill(
						_cabinet_id,
						competence_id,
						skill_json
					);
				END LOOP;
			END IF;

			/*
			Соединяем шаблон с компетенцией
			*/
			INSERT INTO hr.test_template_and_competence
			(
				test_template_id,
				competence_id,
				competence_need_id
			) VALUES(
				_id_test_template,
				competence_id,
				(_competence_copy_json->>'CompetenceNeed')::integer
			);


		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.test_template__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.test_template
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.test_template__insert(
		_cabinet_id integer,
        _title text,
		out _id_template integer,
		_competence_ids integer[] default null,
		_competence_need_ids integer[] default null
	) AS
	$$
		BEGIN
			INSERT INTO hr.test_template 
			(
				cabinet_id,
				title
			) 
			VALUES 
			(
				_cabinet_id,
				_title
			)
			RETURNING id INTO _id_template;
				
			IF  NOT (_competence_ids IS NULL) THEN
				INSERT INTO hr.test_template_and_competence(
					test_template_id,
					competence_id,
					competence_need_id
				)
				SELECT _id_template, unnest(_competence_ids), unnest(_competence_need_ids);
			END IF;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.test_template__update(
		_id integer,
		_title text,
		_competence_ids integer[] default null,
		_competence_need_ids integer[] default null
	) AS
	$$		
		BEGIN
			UPDATE hr.test_template SET title = _title
			WHERE id = _id;
				
			IF  NOT (_competence_ids IS NULL) THEN
				DELETE FROM hr.test_template_and_competence
				WHERE test_template_id = _id;
			
				INSERT INTO hr.test_template_and_competence(
					test_template_id,
					competence_id,
					competence_need_id
				)
				SELECT _id, unnest(_competence_ids), unnest(_competence_need_ids);
			END IF;
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.template__update_constructor(
		_template_json jsonb
	) AS
	$$
		DECLARE competence_json jsonb;

		BEGIN

			IF (_template_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.test_template SET
					title = SUBSTRING((_template_json->'Title')::text, 2, LENGTH((_template_json->'Title')::text) - 2)
				WHERE id = (_template_json->>'Id')::integer;
			END IF;

			DELETE FROM hr.test_template_and_competence
			WHERE test_template_id = (_template_json->>'Id')::integer;

			FOR competence_json IN 
				SELECT value FROM jsonb_array_elements(_template_json->'Competencies')
			LOOP

				INSERT INTO hr.test_template_and_competence
				(
					test_template_id,
					competence_id,
					competence_need_id
				) VALUES(
					(_template_json->>'Id')::integer,
					(competence_json->>'Id')::integer,
					(competence_json->>'CompetenceNeed')::integer
				);

				call hr.competence__update_constructor(
					competence_json
				);
			END LOOP;

		END;
    $$
    LANGUAGE plpgsql;

INSERT INTO hr.skill_need (id,title)
VALUES (1, 'require_hard'),
       (2, 'require_middle'),
	   (3, 'require_soft');

INSERT INTO hr.competence_need (id,title)
VALUES (1, 'require_hard'),
       (2, 'require_middle'),
	   (3, 'require_soft');

INSERT INTO hr.cabinet (id)
VALUES (1),  -- 1
       (2);  -- 2

	   
