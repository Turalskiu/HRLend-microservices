create schema auth;create table auth.cabinet_status
(
    id integer primary key generated by default as identity,
    title text not null
);create table auth.group_type
(
    id integer primary key generated by default as identity,
    title text not null
);create table auth.cabinet
(
    id integer primary key generated by default as identity,
    status_id integer not null,
    title text not null,
    description text,
    date_create timestamp(6) with time zone not null,
    date_delete timestamp(6) with time zone,

    foreign key (status_id) references auth.cabinet_status(id)
);create table auth.group
(
    id integer primary key generated by default as identity,
    cabinet_id integer not null,
    type_id integer not null,
    title text not null,

    foreign key (cabinet_id) references auth.cabinet(id),
    foreign key (type_id) references auth.group_type(id)
);create table auth.role
(
    id integer primary key generated by default as identity,
    title text not null
);create table auth.user_status
(
    id integer primary key generated by default as identity,
    title text not null
);create table auth.user
(
    id integer primary key generated by default as identity,
    status_id integer not null,
    cabinet_id integer not null,
    username text not null unique,
    email text not null unique,
    photo text,
    password_hash text not null,

    date_create timestamp(6) with time zone not null,
    date_delete timestamp(6) with time zone,
    date_activation timestamp(6) with time zone,
    date_blocked timestamp(6) with time zone,
    date_unblocked timestamp(6) with time zone,
    reason_blocked text,

	foreign key (status_id) references auth.user_status(id),
    foreign key (cabinet_id) references auth.cabinet(id)
);create table auth.user_info
(
    user_id integer not null unique,

    first_name text,
    last_name text,
    middle_name text,
    age integer
);create table auth.refresh_token
(
    id integer primary key generated by default as identity,
    user_id integer not null,
    token text not null,
    expires timestamp(6) with time zone not null,
    created timestamp(6) with time zone not null,
    created_by_ip text not null,

    revoked timestamp(6) with time zone,
    revoked_by_ip text,

    replaced_by_token text,
    reason_revoked text,

	foreign key (user_id) references auth.user(id)
);create table auth.registration_token
(
    id integer primary key generated by default as identity,
    user_id integer not null,
    token text not null,
    expires timestamp(6) with time zone not null,
    created timestamp(6) with time zone not null,
    created_by_ip text not null,

    cabinet integer,
    cabinet_role integer,

	foreign key (user_id) references auth.user(id) on delete cascade
);create table auth.user_and_role
(
    user_id integer not null,
    role_id integer not null,

	foreign key (user_id) references auth.user(id) on delete cascade,
    foreign key (role_id) references auth.role(id) on delete cascade
);create table auth.group_and_user
(
    group_id integer not null,
    user_id integer not null,

	foreign key (user_id) references auth.user(id) on delete cascade,
    foreign key (group_id) references auth.group(id) on delete cascade
);CREATE OR REPLACE FUNCTION auth.cabinet__get(
		_id integer
	) RETURNS TABLE (
		status_id integer,
		status_title text,
		title text,
		description text,
		date_create timestamp(6) with time zone,
		date_delete timestamp(6) with time zone
	) AS 
	$$
		BEGIN
			RETURN QUERY 
			SELECT 
				c.status_id AS status_id,
				c_s.title AS status_title,
				c.title AS title,
				c.description AS description,
				c.date_create AS date_create,
				c.date_delete AS date_delete
			FROM auth.cabinet AS c
			JOIN auth.cabinet_status AS c_s ON c_s.id = c.status_id
			WHERE c.id = _id;
		END;
    $$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.cabinet_and_group_and_user__get(
		_ref_cabinet refcursor,
		_ref_group refcursor,
		_ref_user refcursor,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN	

			OPEN _ref_cabinet FOR
				SELECT 
					c.status_id AS status_id,
					c_s.title AS status_title,
					c.title AS title,
					c.description AS description,
					c.date_create AS date_create,
					c.date_delete AS date_delete
				FROM auth.cabinet AS c
				JOIN auth.cabinet_status AS c_s ON c_s.id = c.status_id
				WHERE c.id = _cabinet_id;
			RETURN NEXT _ref_cabinet;

			OPEN _ref_group FOR
				SELECT
					g.id AS id,
					g.title AS title,
					g.type_id AS type_id,
					g_t.title AS type_title
				FROM  auth.group AS g
                JOIN auth.group_type AS g_t ON g.type_id = g_t.id
				WHERE g.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_user;
			
			OPEN _ref_user FOR
				SELECT 
					u.id AS id,
					u.username AS username,
					u.email AS email,
					u.photo AS photo
				FROM auth.user AS u
				WHERE u.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_user;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.cabinet__select(
		_ref_cabinet refcursor,
		_ref_page_info refcursor,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN	

			OPEN _ref_cabinet FOR
				SELECT 
					c.id AS id,
					c.status_id AS status_id,
					c_s.title AS status_title,
					c.title AS title,
					c.description AS description,
					c.date_create AS date_create,
					c.date_delete AS date_delete
				FROM auth.cabinet AS c
				JOIN auth.cabinet_status AS c_s ON c_s.id = c.status_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN c.date_create END ASC,
					CASE WHEN _sort = 'desc' THEN c.date_create END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_cabinet;

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.cabinet
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.group__get(
		_cabinet_id integer,
		_group_id integer
	) RETURNS TABLE (
		title integer,
		type_id text,
		type_title text
	) AS  
	$$
		BEGIN			
			RETURN QUERY
				SELECT
					g.title AS title,
					g.type_id AS type_id,
					g_t.title AS type_title
				FROM  auth.group AS g
				JOIN auth.group_type AS g_t ON g.type_id = g_t.id
				WHERE g.id = _group_id AND g.cabinet_id = _cabinet_id;
		END;	
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION auth.group_and_user__get(
		_ref_group refcursor,
		_ref_user refcursor,
		_cabinet_id integer,
		_group_id integer
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_group FOR
				SELECT
					g.title AS title,
					g.type_id AS type_id,
					g_t.title AS type_title
				FROM  auth.group AS g
                JOIN auth.group_type AS g_t ON g.type_id = g_t.id
				WHERE g.id = _group_id AND g.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_user;
			
			OPEN _ref_user FOR
				SELECT 
					u.id AS id,
					u.username AS username,
					u.email AS email,
					u.photo AS photo
				FROM auth.user AS u
				JOIN auth.group_and_user AS g_a_u ON g_a_u.user_id = u.id
				WHERE g_a_u.group_id = _group_id;
			RETURN NEXT _ref_user;
		END;	
	$$
	LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION auth.group__select(
		_ref_group refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN

			OPEN _ref_group FOR
				SELECT
					g.id AS id,
					g.title AS title,
					g.type_id AS type_id,
					g_t.title AS type_title
				FROM  auth.group AS g
                JOIN auth.group_type AS g_t ON g.type_id = g_t.id
				WHERE g.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN g.title END ASC,
					CASE WHEN _sort = 'desc' THEN g.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_group;		

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.group
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.group__select_by_user(
		_ref_group refcursor,
		_ref_page_info refcursor,
		_user_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN

			OPEN _ref_group FOR
				SELECT
					g.id AS id,
					g.title AS title,
					g.type_id AS type_id,
					g_t.title AS type_title
				FROM  auth.group AS g
                JOIN auth.group_type AS g_t ON g.type_id = g_t.id
				JOIN auth.group_and_user AS g_a_u ON g_a_u.group_id = g.id
				WHERE g_a_u.user_id = _user_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN g.title END ASC,
					CASE WHEN _sort = 'desc' THEN g.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_group;		

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.group AS g
						JOIN auth.group_and_user AS g_a_u ON g_a_u.group_id = g.id
				        WHERE g_a_u.user_id = _user_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION auth.refresh_token__select_by_user(
		_ref_refresh_token refcursor,
		_ref_page_info refcursor,
		_user_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN
			OPEN _ref_refresh_token FOR
				SELECT
                    r_t.id AS id,
					r_t.token AS token,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.revoked AS revoked,
					r_t.revoked_by_ip AS revoked_by_ip,
					r_t.replaced_by_token AS replaced_by_token,
					r_t.reason_revoked AS reason_revoked
				FROM  auth.refresh_token AS r_t
				WHERE r_t.user_id = _user_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN r_t.created END ASC,
					CASE WHEN _sort = 'desc' THEN r_t.created END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_refresh_token;

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.refresh_token
						WHERE user_id = _user_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.registration_token__get(
		_id integer
	) RETURNS TABLE (
		user_id integer,
		token text,
		expires timestamp(6) with time zone,
		created timestamp(6) with time zone,
		created_by_ip text,
		cabinet integer,
		cabinet_role integer
	) AS  
	$$
		BEGIN			
			RETURN QUERY
				SELECT
					r_t.user_id AS user_id,
					r_t.token AS token,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.cabinet AS cabinet,
					r_t.cabinet_role
				FROM  auth.registration_token AS r_t
				WHERE r_t.id = _id;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.registration_token__get(
		_token text
	) RETURNS TABLE (
		id integer,
		expires timestamp(6) with time zone,
		created timestamp(6) with time zone,
		created_by_ip text,
		cabinet integer,
		cabinet_role integer
	) AS  
	$$
		BEGIN			
			RETURN QUERY
				SELECT
					r_t.id AS id,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.cabinet AS cabinet,
					r_t.cabinet_role AS cabinet_role
				FROM  auth.registration_token AS r_t
				WHERE r_t.token = _token;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.registration_token__select(
		_ref_registration_token refcursor,
		_ref_page_info refcursor,
		_user_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN
			OPEN _ref_registration_token FOR
				SELECT
					r_t.id AS id,
					r_t.token AS token,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.cabinet AS cabinet,
					r_t.cabinet_role
				FROM  auth.registration_token AS r_t
				WHERE r_t.user_id = _user_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN r_t.created END ASC,
					CASE WHEN _sort = 'desc' THEN r_t.created END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_registration_token;

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.registration_token
						WHERE user_id = _user_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.user__is_included_cabinet(
    _user_id integer,
    _cabinet_id integer
)
  RETURNS BOOLEAN AS $$
    DECLARE result boolean;
    DECLARE user_cab_id integer;
    BEGIN

        SELECT u.cabinet_id INTO user_cab_id
        FROM auth.user AS u
        WHERE u.id = _user_id;

        IF user_cab_id = _cabinet_id THEN
            result := true;
        ELSE
            result := false;
        END IF;

        RETURN result;
    END;
$$
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user__is_included_cabinet(
    _username text,
    _cabinet_id integer
)
  RETURNS BOOLEAN AS $$
    DECLARE result boolean;
    DECLARE user_cab_id integer;
    BEGIN

        SELECT u.cabinet_id INTO user_cab_id
        FROM auth.user AS u
        WHERE u.username = _username;

        IF user_cab_id = _cabinet_id THEN
            result := true;
        ELSE
            result := false;
        END IF;

        RETURN result;
    END;
$$
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION auth.user__is_exists_username(
    _username text
)
  RETURNS BOOLEAN AS $$
    DECLARE result boolean;
    DECLARE is_username text;

    BEGIN

        SELECT u.username INTO is_username
        FROM auth.user AS u
        WHERE u.username = _username;

        IF is_username IS NULL THEN
            result := false;
        ELSE
            result := true;
        END IF;

        RETURN result;
    END;
$$
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user__is_exists_email(
    _email text
)
  RETURNS BOOLEAN AS $$
    DECLARE result boolean;
    DECLARE is_email text;

    BEGIN

        SELECT u.email INTO is_email
        FROM auth.user AS u
        WHERE u.email = _email;

        IF is_email IS NULL  THEN
            result := false;
        ELSE
            result := true;
        END IF;

        RETURN result;
    END;
$$
LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION auth.user_and_role__get(
		_ref_user refcursor,
		_ref_role refcursor,
		_id integer
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_user FOR
				SELECT
                    u.username AS username,
					u.cabinet_id AS cabinet_id,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u.password_hash AS password_hash,
					u.date_create AS date_create,
					u.date_delete AS date_delete,
					u.date_activation AS date_activation,
					u.date_blocked AS date_blocked,
					u.date_unblocked AS date_unblocked,
					u.reason_blocked AS reason_blocked
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				WHERE u.id = _id;
			RETURN NEXT _ref_user;
			
            OPEN _ref_role FOR
				SELECT
                    r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				WHERE u_a_r.user_id = _id;
			RETURN NEXT _ref_role;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_and_role__get(
		_ref_user refcursor,
		_ref_role refcursor,
		_ref_refresh_token refcursor,
		_username text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_user FOR
				SELECT
                    u.id AS id,
					u.cabinet_id AS cabinet_id,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u.password_hash AS password_hash,
					u.date_create AS date_create,
					u.date_delete AS date_delete,
					u.date_activation AS date_activation,
					u.date_blocked AS date_blocked,
					u.date_unblocked AS date_unblocked,
					u.reason_blocked AS reason_blocked
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				WHERE u.username = _username;
			RETURN NEXT _ref_user;
			
            OPEN _ref_role FOR
				SELECT
					r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				JOIN auth.user AS u ON u_a_r.user_id = u.id
				WHERE u.username = _username;
			RETURN NEXT _ref_role;
			
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_and_role_and_refresh_token__get(
		_ref_user refcursor,
		_ref_role refcursor,
		_ref_refresh_token refcursor,
		_username text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_user FOR
				SELECT
                    u.id AS id,
					u.cabinet_id AS cabinet_id,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u.password_hash AS password_hash,
					u.date_create AS date_create,
					u.date_delete AS date_delete,
					u.date_activation AS date_activation,
					u.date_blocked AS date_blocked,
					u.date_unblocked AS date_unblocked,
					u.reason_blocked AS reason_blocked
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				WHERE u.username = _username;
			RETURN NEXT _ref_user;
			
            OPEN _ref_role FOR
				SELECT
					r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				JOIN auth.user AS u ON u_a_r.user_id = u.id
				WHERE u.username = _username;
			RETURN NEXT _ref_role;
			
			OPEN _ref_refresh_token FOR
				SELECT
                    r_t.id AS id,
					r_t.user_id AS user_id,
					r_t.token AS token,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.revoked AS revoked,
					r_t.revoked_by_ip AS revoked_by_ip,
					r_t.replaced_by_token AS replaced_by_token,
					r_t.reason_revoked AS reason_revoked
				FROM  auth.refresh_token AS r_t
                JOIN auth.user AS u ON u.id = r_t.user_id 
				WHERE u.username = _username;
			RETURN NEXT _ref_refresh_token;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_and_role_and_refresh_token__get_by_refresh_token(
		_ref_user refcursor,
		_ref_role refcursor,
		_ref_refresh_token refcursor,
		_token text
	) RETURNS SETOF refcursor AS 
	$$
		DECLARE
			us_id integer;

		BEGIN	
				
			SELECT r_t.user_id INTO us_id
			FROM auth.refresh_token AS r_t
			WHERE r_t.token = _token;
			
			OPEN _ref_user FOR
				SELECT
                    u.id AS id,
					u.cabinet_id AS cabinet_id,
					u.username AS username,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u.password_hash AS password_hash,
					u.date_create AS date_create,
					u.date_delete AS date_delete,
					u.date_activation AS date_activation,
					u.date_blocked AS date_blocked,
					u.date_unblocked AS date_unblocked,
					u.reason_blocked AS reason_blocked
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				WHERE u.id = us_id;
			RETURN NEXT _ref_user;
			
            OPEN _ref_role FOR
				SELECT
                    r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				WHERE u_a_r.user_id = us_id;
			RETURN NEXT _ref_role;
			
			OPEN _ref_refresh_token FOR
				SELECT
                    r_t.id AS id,
					r_t.user_id AS user_id,
					r_t.token AS token,
					r_t.expires AS expires,
					r_t.created AS created,
					r_t.created_by_ip AS created_by_ip,
					r_t.revoked AS revoked,
					r_t.revoked_by_ip AS revoked_by_ip,
					r_t.replaced_by_token AS replaced_by_token,
					r_t.reason_revoked AS reason_revoked
				FROM  auth.refresh_token AS r_t
				WHERE r_t.user_id = us_id;
			RETURN NEXT _ref_refresh_token;
		END;	
	$$
	LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION auth.user__select(
		_ref_user refcursor,
		_ref_page_info refcursor,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN

			OPEN _ref_user FOR
				SELECT 
					u.id AS id,
					u.username AS username,
					u.email AS email,
					u.photo AS photo
				FROM auth.user AS u
				ORDER BY
					CASE WHEN _sort = 'asc' THEN u.date_create END ASC,
					CASE WHEN _sort = 'desc' THEN u.date_create END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_user;		

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.user
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_and_role__select(
		_ref_user refcursor,
		_ref_role refcursor,
		_ref_page_info refcursor,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN

			CREATE TEMP TABLE temp_user ON COMMIT DROP AS
      		SELECT 
				u.id AS id,
				u.username AS username,
				u.cabinet_id AS cabinet_id,
				u.status_id AS status_id,
				u_s.title AS status_title,
				u.email AS email,
				u.photo AS photo
			FROM auth.user AS u
			JOIN auth.user_status AS u_s ON u.status_id = u_s.id
			ORDER BY
				CASE WHEN _sort = 'asc' THEN u.date_create END ASC,
				CASE WHEN _sort = 'desc' THEN u.date_create END DESC
			LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			
			OPEN _ref_user FOR
				SELECT *
				FROM temp_user;
			RETURN NEXT _ref_user;		
			
            OPEN _ref_role FOR
				SELECT
                    u_a_r.user_id AS user_id,
                    r.id AS role_id,
					r.title AS role_title
				FROM temp_user AS u
                JOIN auth.user_and_role AS u_a_r ON u_a_r.user_id = u.id
				JOIN auth.role AS r ON u_a_r.role_id = r.id;
			RETURN NEXT _ref_role;

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.user
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_and_role__select_by_cabinet(
		_ref_user refcursor,
		_ref_role refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN

			CREATE TEMP TABLE temp_user ON COMMIT DROP AS
      		SELECT 
				u.id AS id,
				u.username AS username,
				u.email AS email,
				u.photo AS photo
			FROM auth.user AS u
			WHERE u.cabinet_id = _cabinet_id
			ORDER BY
				CASE WHEN _sort = 'asc' THEN u.date_create END ASC,
				CASE WHEN _sort = 'desc' THEN u.date_create END DESC
			LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			
			OPEN _ref_user FOR
				SELECT *
				FROM temp_user;
			RETURN NEXT _ref_user;		
			
            OPEN _ref_role FOR
				SELECT
                    u_a_r.user_id AS user_id,
                    r.id AS role_id,
					r.title AS role_title
				FROM temp_user AS u
                JOIN auth.user_and_role AS u_a_r ON u_a_r.user_id = u.id
				JOIN auth.role AS r ON u_a_r.role_id = r.id;
			RETURN NEXT _ref_role;

			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.user
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user__select_by_group(
		_ref_user refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_group_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN
			
			OPEN _ref_user FOR
				SELECT 
					u.id AS id,
					u.username AS username,
					u.email AS email,
					u.photo AS photo
				FROM auth.user AS u
				JOIN auth.group_and_user AS g_a_u ON u.id = g_a_u.user_id
				WHERE g_a_u.group_id = _group_id AND _cabinet_id = u.cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN u.date_create END ASC,
					CASE WHEN _sort = 'desc' THEN u.date_create END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;
			RETURN NEXT _ref_user;		
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM auth.user AS u
						JOIN auth.group_and_user AS g_a_u ON u.id = g_a_u.user_id
						WHERE g_a_u.group_id = _group_id AND _cabinet_id = u.cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION auth.user_info_and_role__get(
		_ref_user refcursor,
		_ref_role refcursor,
		_id integer
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_user FOR
				SELECT
                    u.username AS username,
					u.cabinet_id AS cabinet_id,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u.date_create AS date_create,
					u.date_delete AS date_delete,
					u.date_blocked AS date_blocked,
					u.date_activation AS date_activation,
					u.date_unblocked AS date_unblocked,
					u.reason_blocked AS reason_blocked,
					u_i.first_name AS first_name,
					u_i.middle_name AS middle_name,
					u_i.last_name AS last_name,
					u_i.age AS age
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				JOIN auth.user_info AS u_i ON u_i.user_id = _id
				WHERE u.id = _id;
			RETURN NEXT _ref_user; 
			
            OPEN _ref_role FOR
				SELECT
                    r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				WHERE u_a_r.user_id = _id;
			RETURN NEXT _ref_role;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION auth.user_info_and_role__get(
		_ref_user refcursor,
		_ref_role refcursor,
		_cabinet_id integer,
		_user_id integer
	) RETURNS SETOF refcursor AS 
	$$
		BEGIN			
			OPEN _ref_user FOR
				SELECT
                    u.username AS username,
					u.status_id AS status_id,
                    u_s.title AS status_title,
					u.email AS email,
					u.photo AS photo,
					u_i.first_name AS first_name,
					u_i.middle_name AS middle_name,
					u_i.last_name AS last_name,
					u_i.age AS age
				FROM  auth.user AS u
                JOIN auth.user_status AS u_s ON u_s.id = u.status_id
				JOIN auth.user_info AS u_i ON u_i.user_id = _user_id
				WHERE u.id = _user_id AND u.cabinet_id = _cabinet_id; 
			RETURN NEXT _ref_user; 
			
            OPEN _ref_role FOR
				SELECT
                    r.id AS id,
					r.title AS title
				FROM  auth.role AS r
                JOIN auth.user_and_role AS u_a_r ON u_a_r.role_id = r.id 
				WHERE u_a_r.user_id = _user_id;
			RETURN NEXT _ref_role;
		END;	
	$$
	LANGUAGE plpgsql;
CREATE OR REPLACE PROCEDURE auth.cabinet__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM auth.cabinet
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.cabinet__insert(
        _status_id integer,
        _title text,
		_description text,
		_date_create timestamp(6) with time zone,
		out _id_cabinet integer
	) AS
	$$		
		BEGIN
			INSERT INTO auth.cabinet (
					status_id,
					title,
					description,
					date_create
				) 
				VALUES (
					_status_id,
					_title,
					_description,
					_date_create
				)
			RETURNING id INTO _id_cabinet;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.cabinet__update(
		_id integer,
		_title text,
		_description text
	) AS
	$$		
		BEGIN
			UPDATE auth.cabinet SET 
				title = _title,
				description = _description
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.cabinet__update_status_delete(
        _id integer,
        _status_id integer,
        _date_delete timestamp(6) with time zone
	) AS
    $$		
		BEGIN
			UPDATE auth.cabinet SET 
				status_id = _status_id,
				date_delete = _date_delete
			WHERE id = _id; 
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.group__delete(
        _group_id integer,
		_cabinet_id integer
	) AS
	$$		
		BEGIN
			DELETE FROM auth.group
      		WHERE id = _group_id AND cabinet_id = _cabinet_id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.group__insert(
		_cabinet_id integer,
        _type_id integer,
        _title text,
		out _id_group integer
	) AS
	$$		
		BEGIN
			INSERT INTO auth.group (
					cabinet_id,
					type_id,
					title
				) 
				VALUES (
					_cabinet_id,
					_type_id,
					_title
				)
			RETURNING id INTO _id_group;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.group__update(
		_group_id integer,
		_cabinet_id integer,
		_title text
	) AS
	$$		
		BEGIN
			UPDATE auth.group SET 
				title = _title
			WHERE _group_id = id AND _cabinet_id = cabinet_id; 
		END;
	$$
	LANGUAGE plpgsql;
CREATE OR REPLACE PROCEDURE auth.group_and_user__delete(
        _group_id integer,
		_user_id integer
	) AS
	$$		
		BEGIN
			DELETE FROM auth.group_and_user
      		WHERE group_id = _group_id AND user_id = _user_id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.group_and_user__insert(
        _group_id integer,
		_user_id integer
	) AS
	$$		
		BEGIN
			INSERT INTO auth.group_and_user (
					group_id,
					user_id
				) 
				VALUES (
					_group_id,
					_user_id
				);
		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.group_and_user__insert(
        _group_id integer,
		_user_id integer[]
	) AS
	$$
		DECLARE
			i integer;		
		BEGIN
			FOREACH i IN ARRAY _user_id
			LOOP
				INSERT INTO auth.group_and_user (
						group_id,
						user_id
					) 
					VALUES (
						_group_id,
						i
					);
			END LOOP;

		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.refresh_token__delete(
        _refresh_token_id integer[]
	) AS
	$$	
        DECLARE
			i integer;
		BEGIN
            FOREACH i IN ARRAY _refresh_token_id
			LOOP
				DELETE FROM auth.refresh_token
				WHERE id = i;
			END LOOP;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.refresh_token__insert(
        _user_id integer,
        _token text,
        _expires timestamp(6) with time zone,
        _created timestamp(6) with time zone,
        _created_by_ip text,
		out _is_insert boolean
	) AS
	$$
		BEGIN

			IF EXISTS (SELECT true FROM auth.refresh_token WHERE token = _token) THEN
				_is_insert := false;
			ELSE
				INSERT INTO auth.refresh_token (
					user_id,
					token,
					expires,
                    created,
					created_by_ip
				) 
				VALUES (
					_user_id,
					_token,
					_expires,
                    _created,
					_created_by_ip
				);
				_is_insert := true;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.refresh_token__update(
		_refresh_token_id integer[],
        _revoked timestamp(6) with time zone,
        _revoked_by_ip text,
        _replaced_by_token text,
        _reason_revoked text
	) AS
	$$	
		DECLARE
			i integer;
		BEGIN
			FOREACH i IN ARRAY _refresh_token_id
			LOOP
				UPDATE auth.refresh_token SET 
					revoked = _revoked,
					revoked_by_ip = _revoked_by_ip,
					replaced_by_token = _replaced_by_token,
					reason_revoked = _reason_revoked
				WHERE id = i;
			END LOOP;
		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.refresh_token__update(
        _id integer,
        _revoked timestamp(6) with time zone,
        _revoked_by_ip text,
        _replaced_by_token text,
        _reason_revoked text
	) AS
	$$	
		BEGIN
			UPDATE auth.refresh_token SET 
				revoked = _revoked,
				revoked_by_ip = _revoked_by_ip,
				replaced_by_token = _replaced_by_token,
				reason_revoked = _reason_revoked
			WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.registration_token__delete(
        _id integer
	) AS
	$$	
		BEGIN
			DELETE FROM auth.registration_token
			WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE auth.registration_token__delete(
        _registration_token_id integer[]
	) AS
	$$	
        DECLARE
			i integer;
		BEGIN
            FOREACH i IN ARRAY _registration_token_id
			LOOP
				DELETE FROM auth.registration_token
				WHERE id = i;
			END LOOP;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.registration_token__insert(
        _user_id integer,
        _token text,
        _expires timestamp(6) with time zone,
        _created timestamp(6) with time zone,
        _created_by_ip text,
		_cabinet integer,
		_cabinet_role integer,
		out _is_insert boolean
	) AS
	$$
		BEGIN

			IF EXISTS (SELECT true FROM auth.registration_token WHERE token = _token) THEN
				_is_insert := false;
			ELSE
				INSERT INTO auth.registration_token (
					user_id,
					token,
					expires,
                    created,
					created_by_ip,
					cabinet,
					cabinet_role
				) 
				VALUES (
					_user_id,
					_token,
					_expires,
                    _created,
					_created_by_ip,
					_cabinet,
					_cabinet_role
				);
				_is_insert := true;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.user__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM auth.user
      		WHERE id = _id;

			DELETE FROM auth.user_info
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__delete_role(
		_user_id integer,
		_role_id integer
	) AS
	$$		
		BEGIN

			DELETE FROM auth.user_and_role
      		WHERE user_id = _user_id AND role_id = _role_id;

		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.user__insert(
		_cabinet_id integer,
        _username text,
        _email text,
        _password_hash text,
        _date_create timestamp(6) with time zone,
		_date_activation timestamp(6) with time zone,
        _status_id integer,
		out _id_user integer,
        _role_id integer[] default null
	) AS
	$$
			
		BEGIN
			INSERT INTO auth.user (
					cabinet_id,
					username,
					email,
					password_hash,
					date_create,
					date_activation,
                    status_id
				) 
				VALUES (
					_cabinet_id,
					_username,
					_email,
					_password_hash,
					_date_create,
					_date_activation,
                    _status_id
				)	
			RETURNING id INTO _id_user;
				
			IF  NOT (_role_id IS NULL) THEN
				INSERT INTO auth.user_and_role(
					user_id,
					role_id
				)
				SELECT _id_user, unnest(_role_id);	
			END IF;

			INSERT INTO auth.user_info (
					user_id
				) 
				VALUES (
					_id_user
				);
		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__add_role(
		_user_id integer,
		_role_id integer
	) AS
	$$		
		BEGIN

			INSERT INTO auth.user_and_role(
			  user_id,
			  role_id
			)
			VALUES(
				_user_id,
				_role_id
			);	
		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.user__update_username(
		_id integer,
		_username text
	) AS
	$$		
		BEGIN
			UPDATE auth.user SET 
				username = _username
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__update_photo(
		_id integer,
		_photo text
	) AS
	$$		
		BEGIN
			UPDATE auth.user SET 
				photo = _photo
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__update_password(
		_id integer,
		_password_hash text
	) AS
	$$		
		BEGIN
			UPDATE auth.user SET 
				password_hash = _password_hash
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__update_role(
		_id integer,
		_role_id integer[]
	) AS
	$$		
		BEGIN
			DELETE FROM auth.user_and_role
			WHERE user_id = _id;

			INSERT INTO auth.user_and_role(
			  user_id,
			  role_id
			)
			SELECT _id, unnest(_role_id);	
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__update_status_delete(
        _id integer,
        _status_id integer,
        _date_delete timestamp(6) with time zone
	) AS
    $$		
		BEGIN
			UPDATE auth.user SET 
				status_id = _status_id,
				date_delete = _date_delete
			WHERE id = _id; 
		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE auth.user__update_status_blocked(
        _id integer,
        _status_id integer,
        _date_blocked timestamp(6) with time zone,
		_date_unblocked timestamp(6) with time zone,
		_reason_blocked text
	) AS
    $$		
		BEGIN
			UPDATE auth.user SET 
				status_id = _status_id,
				date_blocked = _date_blocked,
				date_unblocked = _date_unblocked,
				reason_blocked = _reason_blocked
			WHERE id = _id; 
		END;
    $$
    LANGUAGE plpgsql;


	CREATE OR REPLACE PROCEDURE auth.user__update_status_unblocked(
        _id integer,
        _status_id integer,
		_date_unblocked timestamp(6) with time zone
	) AS
    $$		
		BEGIN
			UPDATE auth.user SET 
				status_id = _status_id,
				date_unblocked = _date_unblocked
			WHERE id = _id; 
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE auth.user_info__update(
		_id integer,
		_first_name text,
		_middle_name text,
		_last_name text,
		_age integer
	) AS
	$$		
		BEGIN
			UPDATE auth.user_info SET 
				first_name = _first_name,
				last_name = _last_name,
				middle_name = _middle_name,
				age = _age
			WHERE user_id = _id;
		END;
	$$
	LANGUAGE plpgsql;

INSERT INTO auth.role (id, title)
VALUES (1, 'user'),
       (2, 'admin'),
       (3, 'cabinet_admin'),
       (4, 'cabinet_hr'),
       (5, 'cabinet_employee'),
       (6, 'cabinet_candidate');


INSERT INTO auth.user_status (id, title)
VALUES (1, 'activated'),
       (2, 'blocked'),
       (3, 'deleted');


INSERT INTO auth.cabinet_status (id, title)
VALUES (1, 'activated'),
       (2, 'blocked'),
       (3, 'deleted');


INSERT INTO auth.group_type (id, title)
VALUES (1, 'candidate'),
       (2, 'employee');


INSERT INTO auth.cabinet ( status_id, title, date_create)
VALUES ( 1, 'cab1', '10-06-2023'),  -- 1
       ( 1, 'cab2', '10-06-2023');  -- 2



--pasword = test1
INSERT INTO auth.user ( status_id, cabinet_id, username, email, password_hash, date_create, date_activation)
VALUES (1, 1, 'pavel', 'ibishov.tural20@mail.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),  --1
       (1, 1, 'oleg', 'ibishov.tural22@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --2
       (1, 1, 'lena', 'ibishov.tural23@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --3
       (1, 1, 'vasiliu', 'ibishov.tural24@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --4
       (1, 1, 'maxim', 'ibishov.tural25@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --5
       (1, 1, 'ivan', 'ibishov.tural26@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --6
       (1, 1, 'petr', 'ibishov.tural27@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --7
       (1, 1, 'tom', 'ibishov.tural28@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023'),   --8
       (1, 2, 'jon', 'ibishov.tural30@yandex.ru', '$2a$11$7jh9KCNmLmYjftp8Nxt8AeIUqjCl/012zwTY3QoFyNea4IUG4nX/u', '10-06-2023', '10-06-2023');   --9


INSERT INTO auth.user_info ( user_id)
VALUES (1),  --1
       (2),   --2
       (3),   --3
       (4),   --4
       (5),   --5
       (6),   --6
       (7),   --7
       (8),   --8
       (9);   --9




INSERT INTO auth.user_and_role ( user_id, role_id)
VALUES ( 1, 1),
       ( 1, 2), 
       (1, 3),
       (2, 1),
       (2, 4), 
       (3, 1),
       (3, 5),
       (4,1),
       (4,5),
       (5,1),
       (5,5),
       (6, 1),
       (6, 6),
       (7,1),
       (7,6),
       (8,1),
       (8,6),
       (9, 1),
       (9, 3);

INSERT INTO auth.group ( cabinet_id, type_id, title)
VALUES ( 1, 2, 'for_employee'),  -- 1
       ( 1, 1, 'for_candidate');  -- 2

INSERT INTO auth.group_and_user (group_id, user_id)
VALUES (1, 3),
       (1, 4),
       (2, 6),
       (2, 7);
create schema hr;create table hr.cabinet
(
    id integer primary key
);create table hr.skill_need
(
    id integer primary key generated by default as identity,
	title text not null unique
);create table hr.competence_need
(
    id integer primary key generated by default as identity,
	title text not null unique
);create table hr.test_template
(
    id integer primary key generated by default as identity,
    cabinet_id integer,
	title text not null,
    
    unique(cabinet_id, title),
    foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.competence
(
    id integer primary key generated by default as identity,
    cabinet_id integer,
	title text not null,

    unique(cabinet_id, title),
    foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.skill
(
    id integer primary key generated by default as identity,
	cabinet_id integer,
	title text not null,
	test_module_link text not null,

	unique(cabinet_id, title),
	foreign key (cabinet_id) references hr.cabinet (id) on delete cascade
);create table hr.test_template_and_competence
(
    test_template_id integer not null,
	competence_id integer not null,
	competence_need_id integer not null,

	foreign key (test_template_id) references hr.test_template (id) on delete cascade,
	foreign key (competence_id) references hr.competence (id) on delete cascade,
	foreign key (competence_need_id) references hr.competence_need (id) on delete cascade,
	primary key(test_template_id, competence_id)
);create table hr.competence_and_skill
(
    skill_id integer not null,
	competence_id integer not null,
	skill_need_id integer not null,

	foreign key (skill_id) references hr.skill (id) on delete cascade,
	foreign key (competence_id) references hr.competence (id) on delete cascade,
	foreign key (skill_need_id) references hr.skill_need (id) on delete cascade,
	primary key(skill_id, competence_id)
);
CREATE OR REPLACE FUNCTION hr.competence_and_skill__get(
		_ref_competence refcursor,
		_ref_skill refcursor,
		_id integer,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_competence  FOR
				SELECT
					c.title AS title
				FROM hr.competence  c
				WHERE c.id = _id AND c.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_competence;
				
			OPEN _ref_skill FOR
				SELECT 
					s.id AS skill_id,
					s.title AS skill_title,
					s_n.title AS skill_need_title,
					s_n.id AS skill_need_id
				FROM  hr.skill AS s
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.skill_id = s.id
				JOIN hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id
				where c_a_s.competence_id = _id AND s.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_skill;
			
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.competence__select(
		_ref_competence refcursor,
		_ref_skill refcursor,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN

			CREATE TEMP TABLE temp_competence ON COMMIT DROP AS
      		SELECT * FROM hr.competence AS c
			WHERE c.cabinet_id = _cabinet_id;
		
			OPEN _ref_competence FOR
				SELECT 
					c.id AS id,
					c.title AS title
				FROM temp_competence AS c;
			RETURN NEXT _ref_competence;
			
			OPEN _ref_skill FOR
				SELECT 
					c.id AS competence_id,
					s.id AS skill_id,
					s.title AS skill_title,
					s_n.id AS skill_need_id,
					s_n.title AS skill_need_title
				FROM  temp_competence AS c
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.competence_id = c.id
				JOIN hr.skill AS s ON c_a_s.skill_id = s.id
				join hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id;
			RETURN NEXT _ref_skill;
			
		END;
    $$
	LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION hr.competence__select(
		_ref_competence refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_competence FOR
				SELECT 
					c.id AS id,
					c.title AS title
				FROM hr.competence AS c
				WHERE c.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN c.title END ASC,
					CASE WHEN _sort = 'desc' THEN c.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_competence;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.competence
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.skill__get(
		_id integer,
		_cabinet_id integer
	) RETURNS TABLE (
		title text,
		test_module_link text
	) AS
	$$
		BEGIN
			RETURN QUERY
				SELECT 
					s.title AS title,
					s.test_module_link AS test_module_link
				FROM hr.skill AS s
				WHERE s.id = _id and s.cabinet_id = _cabinet_id;
		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.skill__select(
		_ref_skill refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			
			OPEN _ref_skill FOR
				SELECT 
					s.id AS id,
					s.title AS title,
					s.test_module_link AS test_module_link
				FROM hr.skill AS s
				WHERE s.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN s.title END ASC,
					CASE WHEN _sort = 'desc' THEN s.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_skill;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.skill
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.test_template_and_competence_and_skill__get(
		_ref_test_template refcursor, 
		_ref_competence refcursor, 
		_ref_skill refcursor,
		_id integer,
		_cabinet_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN

			OPEN _ref_test_template FOR
				SELECT 
					t_t.title AS title
				FROM hr.test_template  t_t
				WHERE id = _id AND t_t.cabinet_id = _cabinet_id;
			RETURN NEXT _ref_test_template ;
			
			CREATE TEMP TABLE temp_competence ON COMMIT DROP AS
      		SELECT * FROM hr.competence AS c
            	JOIN hr.test_template_and_competence AS t_t_a_c ON c.id = t_t_a_c.competence_id AND c.cabinet_id = _cabinet_id
			WHERE t_t_a_c.test_template_id = _id;
   
   			OPEN _ref_competence FOR
				SELECT 
					c.id AS competence_id,
					c.title AS competence_title,
					c.competence_need_id AS competence_need_id,
					c_n.title AS competence_need_title
				FROM temp_competence AS c
				JOIN hr.competence_need AS c_n ON c_n.id = c.competence_need_id;
   			RETURN NEXT _ref_competence;
				
			OPEN _ref_skill FOR
				SELECT 
					c.id AS competence_id,
					s.id AS skill_id,
					s.title AS skill_title,
					s.test_module_link AS skill_test_module_link,
					s_n.id AS skill_need_id,
					s_n.title AS skill_need_title
				FROM  temp_competence AS c
				JOIN hr.competence_and_skill AS c_a_s ON c_a_s.competence_id = c.id
				JOIN hr.skill AS s ON c_a_s.skill_id = s.id
				join hr.skill_need AS s_n ON s_n.id = c_a_s.skill_need_id;
			RETURN NEXT _ref_skill;
			
		END;
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION hr.test_template__select(
		_ref_test_template refcursor,
		_ref_page_info refcursor,
		_cabinet_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_test_template FOR
				SELECT 
					t_t.id AS id,
					t_t.title AS title
				FROM hr.test_template AS t_t
				WHERE t_t.cabinet_id = _cabinet_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN t_t.title END ASC,
					CASE WHEN _sort = 'desc' THEN t_t.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_test_template;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM hr.test_template
						WHERE cabinet_id = _cabinet_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.cabinet__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.cabinet
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.cabinet__insert(
        _id integer
	) AS
	$$		
		BEGIN
			INSERT INTO hr.cabinet (
					id
				) 
				VALUES (
					_id
				);
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__copy(
		_cabinet_id integer,
		out _id_competence integer,
		_competence_copy_json jsonb
	) AS
	$$
		DECLARE skill_json jsonb;

		BEGIN

			/*
			Если в кабинете имеются аналогичная компетенция, то узнаем его id,
			и не дублируем.
			*/
			SELECT c.id INTO _id_competence
			FROM hr.competence c
			WHERE 
				c.cabinet_id = _cabinet_id AND
				c.title = SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2);

			IF _id_competence IS NULL THEN
				INSERT INTO hr.competence 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO _id_competence;

				FOR skill_json IN 
					SELECT value FROM jsonb_array_elements(_competence_copy_json->'Skills')
				LOOP
					call hr.hellper__copy_skill(
						_cabinet_id,
						_id_competence,
						skill_json
					);
				END LOOP;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__copy_skill(
		_cabinet_id integer,
		_id_competence integer,
		_skill_copy_json jsonb
	) AS
	$$
		DECLARE skill_id integer;

		BEGIN
			/*
			Если в кабинете имеются аналогичный навык, то узнаем его id,
			и не дублируем.
			*/
			SELECT s.id INTO skill_id
			FROM hr.skill s
			WHERE 
				s.cabinet_id = _cabinet_id AND
				s.title = SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2);

			IF skill_id IS NULL THEN
				INSERT INTO hr.skill 
				(
					cabinet_id,
					title, 
					test_module_link
				) VALUES 
				(
					_cabinet_id,
					 SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2),
					 SUBSTRING((_skill_copy_json->'TestModuleLink')::text, 2, LENGTH((_skill_copy_json->'TestModuleLink')::text) - 2)
				)
				RETURNING id INTO skill_id;
			END IF;

			/*
			Соединяем компетенцию с навыком
			*/
			INSERT INTO hr.competence_and_skill
			(
				competence_id,
				skill_id,
				skill_need_id
			) VALUES(
				_id_competence,
				skill_id,
				(_skill_copy_json->>'SkillNeed')::integer
			);
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.competence
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__insert(
		_cabinet_id integer,
        _title text,
		out _id_competence integer,
		_skill_ids integer[] default null,
		_skill_need_ids integer[] default null
	) AS
	$$
		BEGIN
			INSERT INTO hr.competence 
			(
				cabinet_id,
				title
			) 
			VALUES 
			(
				_cabinet_id,
				_title
			)
			RETURNING id INTO _id_competence;
				
			IF NOT (_skill_ids IS NULL) THEN
				INSERT INTO hr.competence_and_skill(
					competence_id,
					skill_id,
					skill_need_id
				)
				SELECT _id_competence, unnest(_skill_ids), unnest(_skill_need_ids);
			END IF;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.competence__update(
		_id integer,
		_title text,
		_skill_ids integer[] default null,
		_skill_need_ids integer[] default null
	) AS
	$$		
		BEGIN
			UPDATE hr.competence SET title = _title
			WHERE id = _id;
				
			IF  NOT (_skill_ids IS NULL) THEN
				DELETE FROM hr.competence_and_skill
				WHERE competence_id = _id;
			
				INSERT INTO hr.competence_and_skill(
					competence_id,
					skill_id,
					skill_need_id
				)
				SELECT _id, unnest(_skill_ids), unnest(_skill_need_ids);
			END IF;
		END;
	$$
	LANGUAGE plpgsql;



CREATE OR REPLACE PROCEDURE hr.competence__update_constructor(
		_competence_json jsonb
	) AS
	$$
		DECLARE skill_json jsonb;

		BEGIN

			IF (_competence_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.competence SET
					title = SUBSTRING((_competence_json->'Title')::text, 2, LENGTH((_competence_json->'Title')::text) - 2)
				WHERE id = (_competence_json->>'Id')::integer;
			END IF;

			DELETE FROM hr.competence_and_skill
			WHERE competence_id = (_competence_json->>'Id')::integer;

			FOR skill_json IN 
				SELECT value FROM jsonb_array_elements(_competence_json->'Skills')
			LOOP

				INSERT INTO hr.competence_and_skill
				(
					competence_id,
					skill_id,
					skill_need_id
				) VALUES(
					(_competence_json->>'Id')::integer,
					(skill_json->>'Id')::integer,
					(skill_json->>'SkillNeed')::integer
				);

				call hr.hellper__update_skill_constructor(
					skill_json
				);
			END LOOP;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__update_skill_constructor(
		_skill_json jsonb
	) AS
	$$

		BEGIN

			IF (_skill_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.skill SET
					title = SUBSTRING((_skill_json->'Title')::text, 2, LENGTH((_skill_json->'Title')::text) - 2)
				WHERE id = (_skill_json->>'Id')::integer;
			END IF;
				
		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.skill__copy(
		_cabinet_id integer,
		out _id_skill integer,
		_skill_copy_json jsonb
	) AS
	$$
		BEGIN

			/*
			Если в кабинете имеются аналогичный навык, то узнаем его id,
			и не дублируем одинаковые навыки.
			*/
			SELECT s.id INTO _id_skill
			FROM hr.skill s
			WHERE 
				s.cabinet_id = _cabinet_id AND
				s.title = SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2);

			IF _id_skill IS NULL THEN
				INSERT INTO hr.skill 
				(
					cabinet_id,
					title, 
					test_module_link
				) VALUES 
				(
					_cabinet_id,
					SUBSTRING((_skill_copy_json->'Title')::text, 2, LENGTH((_skill_copy_json->'Title')::text) - 2),
					SUBSTRING((_skill_copy_json->'TestModuleLink')::text, 2, LENGTH((_skill_copy_json->'TestModuleLink')::text) - 2)
				)
				RETURNING id INTO _id_skill;
			END IF;
				
		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.skill__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.skill
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.skill__insert(
		_cabinet_id integer,
        _title text,
		_test_module_link text,
		out _id_skill integer
	) AS
	$$
		BEGIN
			INSERT INTO hr.skill 
			(
				cabinet_id,
				title, 
				test_module_link
			) VALUES 
			(
				_cabinet_id,
				_title,
				_test_module_link
			)
			RETURNING id INTO _id_skill;
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.skill__update(
		_id integer,
		_title text,
		_test_module_link text
	) AS
	$$		
		BEGIN
			UPDATE hr.skill 
			SET 
				title = _title,
				test_module_link = _test_module_link
			WHERE id = _id;
				
		END;
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.test_template__copy(
		_cabinet_id integer,
		out _id_test_template integer,
		_template_copy_json jsonb
	) AS
	$$
		DECLARE competence_json jsonb;

		BEGIN

			/*
			Если в кабинете имеются аналогичный шаблон, то узнаем его id,
			и не дублируем.
			*/
			SELECT t.id INTO _id_test_template
			FROM hr.test_template t
			WHERE 
				t.cabinet_id = _cabinet_id AND
				t.title = SUBSTRING((_template_copy_json->'Title')::text, 2, LENGTH((_template_copy_json->'Title')::text) - 2);

			IF _id_test_template IS NULL THEN
				INSERT INTO hr.test_template 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_template_copy_json->'Title')::text, 2, LENGTH((_template_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO _id_test_template;

				FOR competence_json IN 
					SELECT value FROM jsonb_array_elements(_template_copy_json->'Competencies')
				LOOP
					call hr.hellper__copy_competence(
						_cabinet_id,
						_id_test_template,
						competence_json
					);
				END LOOP;
			END IF;

		END;
    $$
    LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.hellper__copy_competence(
		_cabinet_id integer,
		_id_test_template integer,
		_competence_copy_json jsonb
	) AS
	$$
		DECLARE 
			skill_json jsonb;
			competence_id integer;
		BEGIN

			/*
			Если в кабинете имеются аналогичная компетенция, то узнаем его id,
			и не дублируем.
			*/
			SELECT c.id INTO competence_id
			FROM hr.competence c
			WHERE 
				c.cabinet_id = _cabinet_id AND
				c.title = SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2);

			IF competence_id IS NULL THEN
				INSERT INTO hr.competence 
				(
					cabinet_id,
					title
				) 
				VALUES 
				(
					_cabinet_id,
					SUBSTRING((_competence_copy_json->'Title')::text, 2, LENGTH((_competence_copy_json->'Title')::text) - 2)
				)
				RETURNING id INTO competence_id;

				FOR skill_json IN 
					SELECT value FROM jsonb_array_elements(_competence_copy_json->'Skills')
				LOOP
					call hr.hellper__copy_skill(
						_cabinet_id,
						competence_id,
						skill_json
					);
				END LOOP;
			END IF;

			/*
			Соединяем шаблон с компетенцией
			*/
			INSERT INTO hr.test_template_and_competence
			(
				test_template_id,
				competence_id,
				competence_need_id
			) VALUES(
				_id_test_template,
				competence_id,
				(_competence_copy_json->>'CompetenceNeed')::integer
			);


		END;
    $$
    LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE hr.test_template__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM hr.test_template
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.test_template__insert(
		_cabinet_id integer,
        _title text,
		out _id_template integer,
		_competence_ids integer[] default null,
		_competence_need_ids integer[] default null
	) AS
	$$
		BEGIN
			INSERT INTO hr.test_template 
			(
				cabinet_id,
				title
			) 
			VALUES 
			(
				_cabinet_id,
				_title
			)
			RETURNING id INTO _id_template;
				
			IF  NOT (_competence_ids IS NULL) THEN
				INSERT INTO hr.test_template_and_competence(
					test_template_id,
					competence_id,
					competence_need_id
				)
				SELECT _id_template, unnest(_competence_ids), unnest(_competence_need_ids);
			END IF;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE hr.test_template__update(
		_id integer,
		_title text,
		_competence_ids integer[] default null,
		_competence_need_ids integer[] default null
	) AS
	$$		
		BEGIN
			UPDATE hr.test_template SET title = _title
			WHERE id = _id;
				
			IF  NOT (_competence_ids IS NULL) THEN
				DELETE FROM hr.test_template_and_competence
				WHERE test_template_id = _id;
			
				INSERT INTO hr.test_template_and_competence(
					test_template_id,
					competence_id,
					competence_need_id
				)
				SELECT _id, unnest(_competence_ids), unnest(_competence_need_ids);
			END IF;
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE hr.template__update_constructor(
		_template_json jsonb
	) AS
	$$
		DECLARE competence_json jsonb;

		BEGIN

			IF (_template_json->'IsUpdateBody')::boolean = true THEN
				UPDATE hr.test_template SET
					title = SUBSTRING((_template_json->'Title')::text, 2, LENGTH((_template_json->'Title')::text) - 2)
				WHERE id = (_template_json->>'Id')::integer;
			END IF;

			DELETE FROM hr.test_template_and_competence
			WHERE test_template_id = (_template_json->>'Id')::integer;

			FOR competence_json IN 
				SELECT value FROM jsonb_array_elements(_template_json->'Competencies')
			LOOP

				INSERT INTO hr.test_template_and_competence
				(
					test_template_id,
					competence_id,
					competence_need_id
				) VALUES(
					(_template_json->>'Id')::integer,
					(competence_json->>'Id')::integer,
					(competence_json->>'CompetenceNeed')::integer
				);

				call hr.competence__update_constructor(
					competence_json
				);
			END LOOP;

		END;
    $$
    LANGUAGE plpgsql;

INSERT INTO hr.skill_need (id,title)
VALUES (1, 'require_hard'),
       (2, 'require_middle'),
	   (3, 'require_soft');

INSERT INTO hr.competence_need (id,title)
VALUES (1, 'require_hard'),
       (2, 'require_middle'),
	   (3, 'require_soft');

INSERT INTO hr.cabinet (id)
VALUES (1),  -- 1
       (2);  -- 2

	   
create schema test;create table test.user
(
    id integer primary key,
    username text not null,
    email text not null,
    photo text
);create table test.group
(
    id integer primary key,
    title text not null
);create table test.test_link_status
(
    id integer primary key generated by default as identity,
	title text not null
);create table test.test_link_type
(
    id integer primary key generated by default as identity,
	title text not null
);create table test.test_link_response_status
(
    id integer primary key generated by default as identity,
	title text not null
);create table test.test
(
    id integer primary key generated by default as identity,
	hr_id integer not null,
	title text,
	description text,
	test_template_link text not null,

	foreign key (hr_id) references test.user(id) on delete cascade
);create table test.test_link
(
    id integer primary key generated by default as identity,
    test_id integer not null,
    status_id integer not null,
	type_id integer not null,
    user_id integer,
    group_id integer,
    limit_candidate_count integer,
    limit_attempt integer not null,
    candidate_count integer not null,
    title text not null,
	link text not null,
	date_create timestamp(6) with time zone not null,
    date_expired timestamp(6) with time zone not null,
    date_closed timestamp(6) with time zone,
    
	
	foreign key (test_id) references test.test(id) on delete cascade,
	foreign key (status_id) references test.test_link_status(id),
    foreign key (type_id) references test.test_link_type(id),
    foreign key (user_id) references test.user(id) on delete cascade,
    foreign key (group_id) references test.group(id) on delete cascade
);create table test.test_link_response
(
    id integer primary key generated by default as identity,
    test_link_id integer not null,
    status_id integer not null,
    number_attempt integer not null,
    user_id integer,
	date_create timestamp(6) with time zone not null,
    test_generated_link text,
	
	foreign key (test_link_id) references test.test_link(id) on delete cascade,
	foreign key (status_id) references test.test_link_response_status(id),
    foreign key (user_id) references test.user(id) on delete cascade
);create table test.anonymous_user
(
    id integer primary key generated by default as identity,
    test_link_response_id integer not null,
    first_name text not null,
    middle_name text not null,
    last_name text not null,
    email text not null,

    foreign key (test_link_response_id) references test.test_link_response(id) on delete cascade
);create table test.test_result
(
    id integer primary key generated by default as identity,
    test_link_response_id integer not null,
    is_passed boolean,
	test_result_link text not null,
    test_template_statistics_link text not null,

    foreign key (test_link_response_id) references test.test_link_response(id) on delete cascade
);CREATE OR REPLACE FUNCTION test.test__get(
		_ref_test refcursor,
		_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_test FOR
				SELECT 
					t.title AS title,
					t.description AS description,
					t.test_template_link AS test_template_link
				FROM test.test AS t
				WHERE t.id = _id;		
			RETURN NEXT _ref_test;
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION test.test_and_test_link__get(
		_ref_test refcursor,
		_ref_test_link refcursor,
		_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_test FOR
				SELECT 
					t.title AS title,
					t.description AS description,
					t.test_template_link AS test_template_link
				FROM test.test AS t
				WHERE t.id = _id;		
			RETURN NEXT _ref_test;
				
			OPEN _ref_test_link FOR
				SELECT 
					t_l.id AS id,
					t_l.title AS title,
					t_l.status_id AS status_id,
					t_l_s.title AS status_title
				FROM  test.test_link AS t_l
				JOIN test.test_link_status AS t_l_s ON t_l_s.id = t_l.status_id
				where t_l.test_id = _id;
			RETURN NEXT _ref_test_link;
			
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION test.test__get_test_template_link(
		_id integer
	) RETURNS TEXT AS
	$$
		DECLARE
    		result TEXT;
		BEGIN
			
			SELECT 
				t.test_template_link INTO result
			FROM test.test AS t
			WHERE t.id = _id;

			IF result IS NULL THEN
				result := '';
			END IF;

			RETURN result;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION test.test__select(
		_ref_test refcursor,
		_ref_page_info refcursor,
		_hr_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_test FOR
				SELECT 
					t.id AS id,
					t.title AS title
				FROM test.test AS t
				WHERE t.hr_id = _hr_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN t.title END ASC,
					CASE WHEN _sort = 'desc' THEN t.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_test;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM test.test
						WHERE hr_id = _hr_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION test.test_link__is_check_passing_user(
    _link_id integer,
    _user_email text
)
  RETURNS BOOLEAN AS $$
    DECLARE result boolean;
    DECLARE link_id integer;
    BEGIN

        SELECT t_l.id INTO link_id
        FROM test.test_link AS t_l
		JOIN test.test_link_response AS t_l_r ON t_l_r.test_link_id = t_l.id
		JOIN test.anonymous_user AS a_u ON a_u.test_link_response_id = t_l_r.id
        WHERE t_l.id = _link_id AND a_u.email = _user_email;

        IF link_id IS NULL THEN
            result := false;
        ELSE
            result := true;
        END IF;

        RETURN result;
    END;
$$
LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION test.test_link__get_by_link(
		_ref_test_link refcursor,
		_link text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_test_link FOR
				SELECT 
					t_l.id AS id,
					t_l.title AS title,
					t_l.status_id AS status_id,
					t_l_s.title AS status_title,
					t_l.type_id AS type_id,
					t_l_t.title AS type_title,
					t_l.user_id AS user_id,
					u.username AS username,
					u.email AS user_email,
					u.photo AS user_photo,
					t_l.group_id AS group_id,
					t_l.test_id AS test_id,
					g.title AS group_title,
					t_l.limit_candidate_count AS limit_candidate_count,
					t_l.limit_attempt AS limit_attempt,
					t_l.candidate_count AS candidate_count,
					t_l.date_create AS date_create,
					t_l.date_closed AS date_closed,
					t_l.date_expired AS date_expired
				FROM test.test_link AS t_l
				JOIN test.test_link_status AS t_l_s ON t_l_s.id = t_l.status_id
				JOIN test.test_link_type AS t_l_t ON t_l_t.id = t_l.type_id
				LEFT JOIN test.user AS u ON u.id = t_l.user_id
				LEFT JOIN test.group AS g ON g.id = t_l.group_id
				WHERE t_l.link = _link;
			RETURN NEXT _ref_test_link;	
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION test.test_link__get(
		_ref_test_link refcursor,
		_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			OPEN _ref_test_link FOR
				SELECT 
					t_l.title AS title,
					t_l.status_id AS status_id,
					t_l_s.title AS status_title,
					t_l.type_id AS type_id,
					t_l_t.title AS type_title,
					t_l.user_id AS user_id,
					u.username AS username,
					u.email AS user_email,
					u.photo AS user_photo,
					t_l.group_id AS group_id,
					t_l.test_id AS test_id,
					g.title AS group_title,
					t_l.limit_candidate_count AS limit_candidate_count,
					t_l.limit_attempt AS limit_attempt,
					t_l.candidate_count AS candidate_count,
					t_l.link AS link,
					t_l.date_create AS date_create,
					t_l.date_closed AS date_closed,
					t_l.date_expired AS date_expired
				FROM test.test_link AS t_l
				JOIN test.test_link_status AS t_l_s ON t_l_s.id = t_l.status_id
				JOIN test.test_link_type AS t_l_t ON t_l_t.id = t_l.type_id
				LEFT JOIN test.user AS u ON u.id = t_l.user_id
				LEFT JOIN test.group AS g ON g.id = t_l.group_id
				WHERE t_l.id = _id;
			RETURN NEXT _ref_test_link;	
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION test.test_link__select(
		_ref_test_link refcursor,
		_ref_page_info refcursor,
		_hr_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_test_link FOR
				SELECT 
					t_l.id AS id,
					t_l.title AS title,
					t_l.status_id AS status_id,
					t_l_s.title AS status_title
				FROM test.test_link AS t_l
				JOIN test.test_link_status AS t_l_s ON t_l_s.id = t_l.status_id
				JOIN test.test AS t ON t.id = t_l.test_id
				WHERE t.hr_id = _hr_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN t_l.title END ASC,
					CASE WHEN _sort = 'desc' THEN t_l.title END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_test_link;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM test.test_link AS t_l
						JOIN test.test AS t ON t.id = t_l.test_id
						WHERE t.hr_id = _hr_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION test.test_link_response__count(
    _link_id integer,
    _user_id integer
)
  RETURNS integer AS $$
    DECLARE count_passing integer;
    BEGIN

        SELECT COUNT(*) INTO count_passing
        FROM test.test_link_response AS t_l_r
        WHERE t_l_r.user_id = _user_id AND t_l_r.test_link_id = _link_id;

        RETURN count_passing;
    END;
$$
LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION test.test_link_and_user_response__get(
		_ref_test_link_response refcursor,
		_id integer
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
			
			OPEN _ref_test_link_response FOR
				SELECT 
					t_l_r.date_create AS date_create,
					t_l_r.test_link_id AS test_link_id,
					t_l_r.test_generated_link AS test_generated_link,
					t_l_r.user_id AS user_id,
					t_l_r.number_attempt AS number_attempt,
					u.username AS username,
					u.email AS user_email,
					u.photo AS user_photo,
					a_u.id AS anonymous_user_id,
					a_u.first_name AS anonymous_user_first_name,
					a_u.last_name AS anonymous_user_last_name,
					a_u.middle_name AS anonymous_user_middle_name,
					a_u.email AS anonymous_user_email,
					t_l_r_s.id AS status_id,
					t_l_r_s.title AS status_title,
					t_r.id AS test_result_id,
					t_r.test_result_link AS test_result_link,
					t_r.test_template_statistics_link AS test_template_statistics_link,
					t_r.is_passed AS test_is_passed
				FROM test.test_link_response AS t_l_r
				JOIN test.test_link_response_status AS t_l_r_s ON t_l_r.status_id = t_l_r_s.id
				LEFT JOIN test.test_result AS t_r ON t_r.test_link_response_id = t_l_r.id
				LEFT JOIN test.anonymous_user AS a_u ON a_u.test_link_response_id = _id
				LEFT JOIN test.user AS u ON u.id = t_l_r.user_id
				WHERE t_l_r.id = _id;
			RETURN NEXT _ref_test_link_response;
			
		END;	
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION test.test_link_response__get_test_result_link(
		_id integer
	) RETURNS TEXT AS
	$$
		DECLARE
    		result TEXT;
		BEGIN
			
			SELECT 
				t_r.test_result_link INTO result
			FROM test.test_link_response AS t_l_r
			JOIN test.test_result AS t_r ON t_r.test_link_response_id = _id
			WHERE t_l_r.id = _id;

			IF result IS NULL THEN
				result := '';
			END IF;

			RETURN result;
		END;	
	$$
	LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION test.test_link_response_and_user__select(
		_ref_test_link_response refcursor,
		_ref_page_info refcursor,
		_test_link_id integer,
		_page_number integer,
		_page_size integer,
		_sort text
	) RETURNS SETOF refcursor AS
	$$
		BEGIN
		
			OPEN _ref_test_link_response FOR
				SELECT 
					t_l_r.id AS id,
					t_l_r.date_create AS date_create,
					t_l_r.status_id AS status_id,
					t_l_r.number_attempt AS number_attempt,
					t_l_r_s.title AS status_title,
					a_u.id AS anonymous_user_id,
					a_u.first_name AS anonymous_user_first_name,
					a_u.email AS anonymous_user_email,
					t_l_r.user_id AS user_id,
					u.username AS username,
					u.email AS user_email,
					u.photo AS user_photo
				FROM test.test_link_response AS t_l_r
				JOIN test.test_link_response_status AS t_l_r_s ON t_l_r.status_id = t_l_r_s.id
				LEFT JOIN test.anonymous_user AS a_u ON a_u.test_link_response_id = t_l_r.id
				LEFT JOIN test.user AS u ON u.id = t_l_r.user_id
				WHERE t_l_r.test_link_id = _test_link_id
				ORDER BY
					CASE WHEN _sort = 'asc' THEN t_l_r.date_create END ASC,
					CASE WHEN _sort = 'desc' THEN t_l_r.date_create END DESC
				LIMIT _page_size OFFSET (_page_number-1)*_page_size;		
			RETURN NEXT _ref_test_link_response;
			
			OPEN _ref_page_info FOR
				SELECT
					(
						SELECT COUNT(*)::integer FROM test.test_link_response AS t_l_r
						WHERE t_l_r.test_link_id = _test_link_id
					) AS "TotalRows",
					_page_number AS "PageNo",
					_page_size AS "PageSize",
					_sort AS "Sort";	
			RETURN NEXT _ref_page_info;
			
		END;
    $$
	LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.anonymous_user__insert(
		_test_link_response_id integer,
		_first_name text,
		_last_name text,
		_middle_name text,
		_email text,
		out _id_anonymous_user integer
	) AS
	$$
		BEGIN
			INSERT INTO test.anonymous_user
			(
				test_link_response_id,
				first_name,
				last_name,
				middle_name,
				email
			) VALUES 
			(
				_test_link_response_id,
				_first_name,
				_last_name,
				_middle_name,
				_email
			)
			RETURNING id INTO _id_anonymous_user;	
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.group__delete(
        _group_id integer
	) AS
	$$		
		BEGIN
			DELETE FROM test.group
      		WHERE id = _group_id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.group__insert(
		_id integer,
        _title text
	) AS
	$$		
		BEGIN
			INSERT INTO test.group (
					id,
					title
				) 
				VALUES (
					_id,
					_title
				);
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.group__update(
		_id integer,
		_title text
	) AS
	$$		
		BEGIN
			UPDATE test.group SET 
				title = _title
			WHERE _id = id; 
		END;
	$$
	LANGUAGE plpgsql;
CREATE OR REPLACE PROCEDURE test.test__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM test.test
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test__insert(
		_hr_id integer,
        _title text,
		_description text,
		_test_template_link text,
		out _id_test integer
	) AS
	$$
		BEGIN
			INSERT INTO test.test 
			(
				hr_id,
				title, 
				description,
				test_template_link
			) VALUES 
			(
				_hr_id,
				_title, 
				_description,
				_test_template_link
			)
			RETURNING id INTO _id_test;
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test__update(
		_id integer,
		_title text,
		_description text
	) AS
	$$		
		BEGIN
			UPDATE test.test
			SET 
				title = _title,
				description = _description
			WHERE id = _id;
				
		END;
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE test.test_link__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM test.test_link
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test_link__insert(
		_test_id integer,
        _status_id integer,
		_type_id integer,
		_user_id integer,
		_group_id integer,
		_limit_candidate_count integer,
		_limit_attempt integer,
		_title text,
		_link text,
		_date_create timestamp(6) with time zone,
		_date_expired timestamp(6) with time zone,
		out _id_test_link integer
	) AS
	$$
		BEGIN
			INSERT INTO test.test_link
			(
				test_id,
				status_id,
				type_id,
				user_id,
				group_id,
				limit_candidate_count,
				limit_attempt,
				candidate_count,
				title,
				link,
				date_create,
				date_expired
			) VALUES 
			(
				_test_id,
				_status_id,
				_type_id,
				_user_id,
				_group_id,
				_limit_candidate_count,
				_limit_attempt,
				0,
				_title,
				_link,
				_date_create,
				_date_expired
			)
			RETURNING id INTO _id_test_link;
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test_link__update(
		_id integer,
		_status_id integer
	) AS
	$$		
		BEGIN
			UPDATE test.test_link
			SET 
				status_id = _status_id
			WHERE id = _id;		
		END;
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE test.test_link__closed(
		_id integer,
		_status_id integer,
		_date_closed timestamp(6) with time zone
	) AS
	$$		
		BEGIN
			UPDATE test.test_link
			SET 
				status_id = _status_id,
				date_closed = _date_closed
			WHERE id = _id;		
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE test.test_link__candidate_count_increase(
		_id integer
	) AS
	$$		
		BEGIN
			UPDATE test.test_link 
			SET
				candidate_count = (candidate_count + 1)
			WHERE id =_id;
		END;
	$$
	LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE test.test_link_response__delete(
        _id integer
	) AS
	$$		
		BEGIN
			DELETE FROM test.test_link_response
      		WHERE id = _id;
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test_link_response__insert(
		_test_link_id integer,
        _status_id integer,
		_user_id integer,
		_number_attempt integer,
		_test_generated_link text,
		_date_create timestamp(6) with time zone,
		out _id_test_link_response integer
	) AS
	$$
		BEGIN
			INSERT INTO test.test_link_response
			(
				test_link_id,
				status_id,
				user_id,
				number_attempt,
				test_generated_link,
				date_create
			) VALUES 
			(
				_test_link_id,
				_status_id,
				_user_id,
				_number_attempt,
				_test_generated_link,
				_date_create
			)
			RETURNING id INTO _id_test_link_response;	
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.test_link_response__update(
		_id integer,
		_status_id integer
	) AS
	$$		
		BEGIN
			UPDATE test.test_link_response
			SET 
				status_id = _status_id
			WHERE id = _id;		
		END;
	$$
	LANGUAGE plpgsql;



CREATE OR REPLACE PROCEDURE test.test_result__insert(
		_test_link_response_id integer,
        _is_passed boolean,
		_test_result_link text,
		_test_template_statistics_link text,
		out _id_test_result integer
	) AS
	$$
		BEGIN
			INSERT INTO test.test_result
			(
				test_link_response_id,
				is_passed,
				test_result_link,
				test_template_statistics_link
			) VALUES 
			(
				_test_link_response_id,
				_is_passed,
				_test_result_link,
				_test_template_statistics_link
			)
			RETURNING id INTO _id_test_result;
				
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.user__insert(
		_id integer,
		_username text,
		_photo text,
		_email text
	) AS
	$$
		BEGIN
			INSERT INTO test.user
			(
				id,
				username,
				photo,
				email
			) VALUES 
			(
				_id,
				_username,
				_photo,
				_email
			);
		END;
    $$
    LANGUAGE plpgsql;CREATE OR REPLACE PROCEDURE test.user__update_username(
		_id integer,
		_username text
	) AS
	$$		
		BEGIN
			UPDATE test.user SET 
				username = _username
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE test.user__update_photo(
		_id integer,
		_photo text
	) AS
	$$		
		BEGIN
			UPDATE test.user SET 
				photo = _photo
			WHERE id = _id; 
		END;
	$$
	LANGUAGE plpgsql;


INSERT INTO test.test_link_type (id, title)
VALUES (1, 'for_user'),
       (2, 'for_group'),
       (3, 'for_anonymous_user'),
       (4, 'for_anonymous_group');

INSERT INTO test.test_link_status (id, title)
VALUES (1, 'open'),
       (2, 'closed'),
       (3, 'expired'),
       (4, 'limit');


INSERT INTO test.test_link_response_status (id, title)
VALUES (1, 'respond'),
       (2, 'start_test'),
       (3, 'end_test'),
       (4, 'overdue_test');

INSERT INTO test.user (id, username, email)
VALUES (1, 'pavel', 'ibishov.tural20@mail.ru'),  --1
       (2, 'oleg', 'ibishov.tural22@yandex.ru'),   --2
       (3, 'lena', 'ibishov.tural23@yandex.ru'),   --3
       (4, 'vasiliu', 'ibishov.tural24@yandex.ru'),   --4
       (5, 'maxim', 'ibishov.tural25@yandex.ru'),   --5
       (6, 'ivan', 'ibishov.tural26@yandex.ru'),   --6
       (7,'petr', 'ibishov.tural27@yandex.ru'),   --7
       (8,'tom', 'ibishov.tural28@yandex.ru'),   --8
       (9,'jon', 'ibishov.tural30@yandex.ru');   --9

INSERT INTO test.group (id, title)
VALUES (1, 'for_employee'),  -- 1
       (2, 'for_candidate');  -- 2
